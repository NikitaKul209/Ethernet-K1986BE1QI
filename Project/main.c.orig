
#include "main.h"












// ????? ??? ??????????? ethernet
#define ETH_RAM_BASE_ADDR	(unsigned int)0x38000000
// ?????? ?????? ??? ethernet
#define ETH_RAM_FULL_SIZE	8192	// ? ??????
// ???????? ???
#define ETH_RAM_HALF	(ETH_RAM_FULL_SIZE >> 1)
// ?????? ??? ?????????
#define ETH_RAM_SIZE_R	ETH_RAM_HALF
// ?????? ??? ???????????
#define ETH_RAM_SIZE_X	ETH_RAM_HALF
// ?????? ?????? ??????? ????????? ? ???????????
#define ETH_RAM_BASE_R		ETH_RAM_BASE_ADDR
#define ETH_RAM_BASE_X		(ETH_RAM_BASE_ADDR + ETH_RAM_SIZE_R)




#define FCLK		16							// частота генератора МГц
extern unsigned int PLL_Mul;					// коэффициент умножения PLL
#define CPU_CLK		(FCLK * (PLL_Mul + 1))
#define	DELAY(d)	(FCLK * (PLL_Mul + 1) * (d) / 1000 + 1)	// FCLK * (PLL_Mul + 1) * d / 1000 + 1

//---------------------------------------------------------------------------------------------------
// полезные макро
#define BM(n)		(1ul << (n))

#define LOBYTE(w)         (unsigned char)(w)
#define HIBYTE(w)         (unsigned char)((w) >> 8)
#define MAKEWORD(lo, hi)  ((unsigned short)(unsigned char)(lo) | ((unsigned short)(unsigned char)(hi) << 8))

#define HINIBBLE(b)			(((unsigned char)(b) & 0xF0) >> 4)
#define LONIBBLE(b)			((unsigned int)(b) & 0x0F)

#define EXCHANGE(a) (((unsigned short)(a) >> 8) | (((unsigned short)(a) & 0xFF) << 8))

#define NO	((unsigned short)(-1))
//---------------------------------------------------------------------------------------------------
#define PHY_ADDR			0x1C
#define PHY_DEFAULT_MODE	PHY_MODE_10BaseT_FDn

//------------------------------------------------------------
// значение регистра задания предделителя шага изменения BAG и JitterWnd в мкс
#define PSC_VAL(v)	(CPU_CLK * (v) - 1)
// значение для регистра периода следования пакетов в мкс
#define BAG_PERIOD(t)	(CPU_CLK * (t))
// значение для регистра джиттера при передачи пакетов в мкс
#define JITTER_WND(t)	(CPU_CLK * (t) - 1)

// количество попыток обмена
#define EXCH_ATTEMPT	10
// размер окна коллизий
#define COLL_WND		(1ul << 7)

//------------------------------------------------------------
//------------------------------------------------------------
// определения для модуля PHY
// регистр управления
#define bPHY_BN_nRST				BM(0)

#define PHY_CTRL_MODE				1
#define mPHY_CTRL_MODE				(0x7ul << PHY_CTRL_MODE)

#define bPHY_CTRL_FX_EN				BM(7)
#define bPHY_CTRL_MDI				BM(8)
#define bPHY_CTRL_MDIO_SEL			BM(9)
#define bPHY_CTRL_MDC				BM(10)

#define PHY_CTRL_PHYADD				11
#define mPHY_CTRL_PHYADD			(0x1Ful << PHY_CTRL_PHYADD)

// режимы работы
enum
{
  PHY_MODE_10BaseT_HDn, 	// n - без автоподстройки
  PHY_MODE_10BaseT_FDn,
  PHY_MODE_100BaseT_HDn,
  PHY_MODE_100BaseT_FDn,
  PHY_MODE_100BaseT_HD,
  PHY_MODE_TRANSLATOR, 	// повторитель
  PHY_MODE_LOW_CONS,		// пониженное потребление
  PHY_MODE_AUTO,			// автоматический режим
  PHY_MODE_CNT
};

//------------------------------------------------------------
// регистр состояния PHY
#define bPHY_STAT_LED0		BM(0)	// 0 - 100Мбит, 1 - 10Мбит
#define bPHY_STAT_LED1		BM(1)	// 0 - link вкл, 1 - link выкл
#define bPHY_STAT_LED2		BM(2)	// 0 - наличие CRS, 1 - отсутствие CRS
#define bPHY_STAT_LED3		BM(3)	// 0 - fill-duplex, 1 - half-duplex
#define bPHY_STAT_READY		BM(4)	// 0 - не готов, 1 - готов
#define bPHY_STAT_CRS		BM(5)	// 1 - выполняется обмен
#define bPHY_STAT_COL		BM(6)	// 1 - коллизия
#define bPHY_STAT_FX_VALID	BM(8)	// 1 - обмен в линии FX
#define bPHY_STAT_MDO		BM(9)	// состояние выхода данных SMI для ручного управления 
#define bPHY_STAT_MDINT		BM(10)	// прерывание от блока PHY

//------------------------------------------------------------
//------------------------------------------------------------
// адрес ОЗУ контроллера ethernet
#define ETH_RAM_BASE_ADDR	(unsigned int)0x38000000
// полный размер ОЗУ ethernet
#define ETH_RAM_FULL_SIZE	8192	// в байтах
// половина ОЗУ
#define ETH_RAM_HALF	(ETH_RAM_FULL_SIZE >> 1)
// размер ОЗУ приемника
#define ETH_RAM_SIZE_R	ETH_RAM_HALF
// размер ОЗУ передатчика
#define ETH_RAM_SIZE_X	ETH_RAM_HALF
// адреса начала буферов приемника и передатчика
#define ETH_RAM_BASE_R		ETH_RAM_BASE_ADDR
#define ETH_RAM_BASE_X		(ETH_RAM_BASE_ADDR + ETH_RAM_SIZE_R)

//------------------------------------------------------------
//------------------------------------------------------------
// Ethernet

// регистр состояния передачи пакета
// поле управления передачи пакета
#define mETH_X_LENGTH		0xFFFFul
// поле состояния передачи пакета
#define ETH_X_STAT_RCNT		16
#define mETH_X_STAT_RCNT	(0xFul << ETH_X_STAT_RCNT)
// флаг исчерпания попыток передачи пакета
#define bETH_X_STAT_RL		BM(20)
// флаг индикации late collision во времы передачи пакета
#define bETH_X_STAT_LC		BM(21)
// флаг опустошения буфера передачи
#define bETH_X_STAT_UR		BM(22)

//------------------------------------------------------------
// регистр состояния приема пакета
// количество байт в пакете включая заголовок и CRC
#define mETH_R_LENGTH		0xFFFFul
// признак пакета PAUSE
#define bETH_R_PF_ERR		BM(16)
// признак пакета управления
#define bETH_R_CF_ERR		BM(17)
// признак превышения длины пакета 1518 октетов
#define bETH_R_LF_ERR		BM(18)
// признак недостаточной длинны пакета
#define bETH_R_SF_ERR		BM(19)
// признак несоответствия между реальной длинной и длинной
// указанной в поле длинны
#define bETH_R_LEN_ERR		BM(20)
// количество бит в пакете не кратно 8
#define bETH_R_DN_ERR		BM(21)
// признак несоответствия CRC пакета
#define bETH_R_CRC_ERR		BM(22)
// признак наличия в пакете ошибочных nibbles
#define bETH_R_SMB_ERR		BM(23)
// признак группового пакета
#define bETH_R_MCA			BM(24)
// признак широковещательного пакета
#define bETH_R_BCA			BM(25)
// признак индивидуального пакета
#define bETH_R_UCA			BM(26)

//------------------------------------------------------------
// регистр общего управления блоком
// размер окна коллизий
#define mETH_CTRL_COL_WND	0xFFul
// автоматическая обработка пакета PAUSE
#define bETH_CTRL_PAUSE_EN	BM(8)
// режим детерминированного времени доставки
#define bETH_CTRL_DTRM_EN	BM(9)
// полудуплексный режим работы
#define bETH_CTRL_HD_EN		BM(10)
// включение режима дополнения коротких пакетов ???
#define bETH_CTRL_EXT_EN	BM(11)
// режим работы буфера
#define ETH_CTRL_BUFF_MODE	12
// режимы работы
enum
{
  BWM_LIN,	// линейный
  BWM_AUTO,	// автоматической изменение указателей
  BWM_FIFO
};
#define mETH_CTRL_BUFF_MODE	(0x3ul << ETH_CTRL_BUFF_MODE)
// сброс передатчика ???
#define bETH_CTRL_RCLR_EN	BM(14)	// сброс передатчика 1 - сброшен
#define bETH_CTRL_XRST		BM(16)	// сброс передатчика 1 - сброшен
// сброс приемника
#define bETH_CTRL_RRST		BM(17)
// режим КЗ
#define bETH_CTRL_DLB		BM(18)
// разрешение автоматического изменения указателей FIFO
// приемника в режиме отладки
#define bETH_CTRL_DBG_RF_EN	BM(28)
// разрешение автоматического изменения указателей FIFO
// передатчика
#define bETH_CTRL_DBG_XF_EN	BM(29)
// режим работы в режиме отладки
#define ETH_DBG_MODE		30
enum
{
  DBG_WM_FREERUN,
  DBG_WM_HALT = 2,
  DBG_WM_STOP
};
#define mETH_DBG_MODE		(0x3ul << ETH_DBG_MODE)

//------------------------------------------------------------
// регистр управления передатчиком
// максимальное кол-во попыток обмена
#define mETH_X_CFG_RTRY_CNT		0xFul
// выдержка паузы между отправкой пакетов
#define bETH_X_CFG_IPG_EN		BM(4)
// дополнение пакета автоматически высчитанным CRC
#define bETH_X_CFG_CRC_EN		BM(5)
// дополненение пакета преамбулой
#define bETH_X_CFG_PRE_EN		BM(6)
// дополнение пакета до минимальной длинны PAD-ами
#define bETH_X_CFG_PAD_EN		BM(7)
// выбор режима работы вывода EVNT[1]
#define ETH_X_CFG_EVNT_MODE		8
enum
{
  EVNT_MODE_XFIFO_EMPTY,		// пуст
  EVNT_MODE_XFIFO_NEAR_EMPTY,	// почти пуст
  EVNT_MODE_XFIFO_HALF,		// полон на половину
  EVNT_MODE_XFIFO_NEAR_FULL,	// почти полон
  EVNT_MODE_XFIFO_FULL,		// полон
  EVNT_MODE_XFIFO_SND_FNSH, 	// отправка завершена
  EVNT_MODE_XFIFO_READ_WORD_FROM_BUF,	// считал слово данных из буфера
  EVNT_MODE_XFIFO_NEXT_ATTM	// очередная попятка передачи пакета
};
#define mETH_X_CFG_EVNT_MODE	(0x7ul << ETH_X_CFG_EVNT_MODE)
// порядок следования бит при передачи байтов данных
#define bETH_X_CGF_MSB1ST		BM(12) // 0 - LSB, 1 - MSB
// порядок следования байт
#define bETH_X_CFG_BE			BM(14)	// 0 - little endian, 1 - big endian
// разрешение работы передатчика
#define bETH_X_CFG_EN			BM(15)

//------------------------------------------------------------
// регистр управления приемником
// прием пакетов с групповым MAC-адресом, с фильтрацией по HASH таблице
#define bETH_R_CFG_MCA_EN		BM(0)
// прием пакетов с широковещательным MAC
#define bETH_R_CFG_BCA_EN		BM(1)
// прием пакетов с MAC	указанным в регистре MAC_Address
#define bETH_R_CFG_UCA_EN		BM(2)
// прием пакетов без фильтрации MAC
#define bETH_R_CFG_AC_EN		BM(3)
// разрешение приема пакетов с ошибками
#define bETH_R_CFG_EF_EN		BM(4)
// разрешение приема управляющих пакетов
#define bETH_R_CFG_CF_EN		BM(5)
// разрешение приема пакетов длинной больше максимальной
#define bETH_R_CFG_LF_EN		BM(6)
// разрешение приема пакетов длинной меньше минимальной
#define bETH_R_CFG_SF_EN		BM(7)

// выбор режима работы вывода EVNT[1]
#define ETH_R_CFG_EVNT_MODE		8
enum
{
  EVNT_MODE_RFIFO_NO_EMPTY,		// не пуст
  EVNT_MODE_RFIFO_NEAR_NO_EMPTY,	// почти не пуст
  EVNT_MODE_RFIFO_HALF,		// пуст на половину
  EVNT_MODE_RFIFO_NEAR_NO_FULL,	// почти не полон
  EVNT_MODE_RFIFO_NO_FULL,		// не полон
  EVNT_MODE_RFIFO_RCV_FNSH, 	// прием завершен
  EVNT_MODE_RFIFO_WRITE_WORD_TO_BUF,	// положил данные в буфер
  EVNT_MODE_RFIFO_KICK		// отбросил пакет
};
#define mETH_R_CFG_EVNT_MODE	(0x7ul << ETH_R_CFG_EVNT_MODE)
// порядок следования бит при приеме байтов данных
#define bETH_R_CGF_MSB1ST		BM(12) // 0 - LSB, 1 - MSB
// порядок следования байт
#define bETH_R_CFG_BE			BM(14)	// 0 - little endian, 1 - big endian
// разрешение работы приемника
#define bETH_R_CFG_EN			BM(15)

//------------------------------------------------------------
// регистр маски IMR и флагов IFR прерываний
// индикатор успешно принятого пакета
#define bETH_IMR_RF_OK			BM(0)
#define bETH_IFR_RF_OK			bETH_IMR_RF_OK
// потеря пакета из-за отсутствия места в буфере
#define bETH_IMR_MISSED_F		BM(1)
#define bETH_IFR_MISSED_F		bETH_IMR_MISSED_F
// переполнение буфера приемника
#define bETH_IMR_OVF			BM(2)
#define bETH_IFR_OVF			bETH_IMR_OVF
// наличие ошибок в данных при приеме пакета
#define bETH_IMR_SMB_ERR		BM(3)
#define bETH_IFR_SMB_ERR		bETH_IMR_SMB_ERR
// несовпадение CRC пакета принятых данных с CRC пакета
#define bETH_IMR_CRC_ERR		BM(4)
#define bETH_IFR_CRC_ERR		bETH_IMR_CRC_ERR
// прием управляющих пакетов
#define bETH_IMR_CF				BM(5)
#define bETH_IFR_CF				bETH_IMR_CF
// пакет длинны более максимальной
#define bETH_IMR_LF				BM(6)
#define bETH_IFR_LF				bETH_IMR_LF
// пакет длинны менее минимальной
#define bETH_IMR_SF				BM(7)
#define bETH_IFR_SF				bETH_IMR_SF
//  успешная отправка пакета
#define bETH_IMR_XF_OK			BM(8)
#define bETH_IFR_XF_OK			bETH_IMR_XF_OK
// наличие ошибок при передаче пакета
#define bETH_IMR_XF_ERR			BM(9)
#define bETH_IFR_XF_ERR			bETH_IMR_XF_ERR
// опустошение буфера передатчика
#define bETH_IMR_UNDF			BM(10)
#define bETH_IFR_UNDF			bETH_IMR_UNDF
// наличие late collision в линии
#define bETH_IMR_LC				BM(11)
#define bETH_IFR_LC				bETH_IMR_LC
// потеря несущей во время передачи в полудуплексном режиме
#define bETH_IMR_CRS_LOST		BM(12)
#define bETH_IFR_CRS_LOST		bETH_IMR_CRS_LOST
// прерывание по MDIO интерфейсу
#define bETH_IMR_MDIO_INT		BM(14)
#define bETH_IFR_MDIO_INT		bETH_IMR_MDIO_INT
// завершение текущей команжы по MDIO интерфейсу
#define bETH_IMR_MII_RDY		BM(15)
#define bETH_IFR_MII_RDY		bETH_IMR_MII_RDY

//------------------------------------------------------------
// регистр статуса
// буфер приемника пуст
#define	bETH_STAT_R_EMPTY		BM(0)
// буфер приемника почти пуст
#define	bETH_STAT_R_AEMPTY		BM(1)
// буфер приемника полуполон
#define	bETH_STAT_R_HALF		BM(2)
// буфер приемника почти полон
#define	bETH_STAT_R_AFULL		BM(3)
//  буфер приемника полон
#define	bETH_STAT_R_FULL		BM(4)

// количество принятых, но не считанных пакетов
#define	ETH_STAT_R_CNT			5
#define	mETH_STAT_R_CNT			(0x7ul << ETH_STAT_R_CNT)

// буфер передатчика пуст
#define bETH_STAT_X_EMPTY		BM(8)
// буфер передатчика почти пуст
#define bETH_STAT_X_AEMPTY		BM(9)
// буфер передатчика полуполон
#define bETH_STAT_X_HALF		BM(10)
// буфер передатчика почти полон
#define bETH_STAT_X_AFULL		BM(11)
// буфер передатчика полон
#define bETH_STAT_X_FULL		BM(12)

//------------------------------------------------------------
// регистр управления MDIO
// номер регистра PHY
#define mETH_PHY_MDIO_REG			0x1Ful
// коэффициент деления основной частоты для MDIO
#define ETH_PHY_MDIO_DIV			5
#define mETH_PHY_MDIO_DIV			(0x7ul << ETH_PHY_MDIO_DIV)
// адрес модуля
#define ETH_PHY_MDIO_ADDR			5
#define mETH_PHY_MDIO_ADDR			(0x1Ful << ETH_PHY_MDIO_ADDR)
// операция
#define bETH_PHY_MDIO_OP			BM(13)	// 1 - rd, 0 - wr
// режим передачи
#define bETH_PHY_MDIO_PRE_EN		BM(14)	// 1 -  с преамбулой
// управление/индикатор обмена по MDIO
#define bETH_PHY_MDIO_RDY			BM(15)

unsigned int CalcSum(void* buf, unsigned int size);
unsigned short CalcHeaderCS(void* buf, unsigned int size);


extern uint8_t DA_MAC_Address[6];
extern uint8_t SA_MAC_Address[6];
extern uint8_t SA_IP_Address[6];
extern uint8_t DA_IP_Address[6];
uint8_t output_frame [1500] ;
uint32_t input_frame [1500] ;
uint8_t bufflen = 42;
unsigned int ethernet_WriteRAM(void* buf, unsigned int size);
void arp(uint8_t* packet,uint16_t length);
void ARP_REQUEST(void);

bool  timer_flag = false;














#define ETH_TYPE_ARP     0x0806
#define ETH_TYPE_IPV4     0x0800

#define ARP_REQ           0x01
#define ARP_REP           0x02
#define ARP_HTYPE_ETH 0x0001
#define ARP_PTYPE 0x0800
#define ARP_HLEN 0x06
#define ARP_PLEN 0x4

#define IP_ADDR_SIZE 4
#define MAC_ADDR_SIZE 6


typedef struct
{

  uint8_t dest_mac [6];
  uint8_t source_mac [6];
  uint16_t 	ethernet_type;
} ethernet_header_s;

typedef struct
{


  uint16_t hw_type;
  uint16_t pr_type;
  uint8_t hw_length;
  uint8_t pr_length;
  uint16_t operation;
  uint8_t	sender_mac[6];
  uint8_t sender_ip[4];
  uint8_t target_mac[6];
  uint8_t target_ip[4];

} arp_packet_s;


enum
{

  ARP,
  ICMP,
  UDP,
  LISTENING

} ethernet_states;






int main(void)
{
  set_clk();
  set_timer();
  set_port();
  set_adc();
//  set_ethernet();
  NVIC_EnableIRQ(ETHERNET_IRQn);
  Ethernet_Init();







//  TIMER_Cmd(MDR_TIMER2, ENABLE);
//    ADC1_Start();


  PORT_WriteBit(MDR_PORTA, PORT_Pin_9,true);
  uint8_t val = 0;
  while(1)
    {




      switch(ethernet_states)
        {


        case ARP:
          break;
        case ICMP:
          break;
        case UDP:
          break;
        case LISTENING:
          break;

        }


      if(timer_flag)
        {

          val = ~val;
          PORT_ResetBits(MDR_PORTC,PORT_Pin_9);
          PORT_WriteBit(MDR_PORTA, PORT_Pin_9,val);
          timer_flag = false;

//          ARP_REQUEST();
          TIMER_Cmd(MDR_TIMER2, ENABLE);


        }





    }



}

void arp(uint8_t* packet,uint16_t length)
{

  ethernet_header_s* rec_ethernet_header = (ethernet_header_s*)packet;
  arp_packet_s* rec_arp_packet = (arp_packet_s*)(packet + sizeof(ethernet_header_s));


  if (memcmp(rec_arp_packet->target_ip, SA_IP_Address, IP_ADDR_SIZE) != 0)
    {
      ethernet_states = LISTENING;
      return;
    }
		if ((rec_arp_packet->operation) == ARP_REQ){
		
		
		  ethernet_header_s* tx_ethernet_header =(ethernet_header_s*) output_frame;
  arp_packet_s* tx_arp_packet =(arp_packet_s*) (packet+14);

  tx_arp_packet->hw_type = ARP_HTYPE_ETH;
  tx_arp_packet->pr_type = ARP_PTYPE;
  tx_arp_packet->hw_length =ARP_HLEN;
  tx_arp_packet->pr_length =ARP_PLEN;
  tx_arp_packet->operation = ARP_REP;
  memcpy(tx_arp_packet->sender_mac, SA_MAC_Address,6);
  memcpy(tx_arp_packet->sender_ip,SA_IP_Address,6);
  memcpy(tx_arp_packet->target_mac,rec_arp_packet->sender_mac,6);
  memcpy(tx_arp_packet->target_ip,rec_arp_packet->sender_ip,6);

  ethernet_WriteRAM(output_frame,42);
  ethernet_states = LISTENING;
		
		}



}

void PING_ECHO(void)
{



//eth
  memcpy(&output_frame[0],DA_MAC_Address,6);
  memcpy(&output_frame[6],SA_MAC_Address,6);
  output_frame[12] = 0x8;
  output_frame[13] = 0x0;

//ip
  output_frame[14] = 0x45;
  output_frame[15] = 0x0;
  output_frame[16] = 0x00;
  output_frame[17] = 0x3C;

  output_frame[18] = 0xfe;
  output_frame[19] = 0x7d;

  output_frame[20] = 0x0;
  output_frame[21] = 0x0;

  output_frame[22] = 0x80;
  output_frame[23] = 0x01;

  output_frame[24] = 0x0;
  output_frame[25] = 0x0;
  memcpy(&output_frame[26],SA_IP_Address,4);
  memcpy(&output_frame[30],DA_IP_Address,4);

//icmp
  output_frame[34] = 0x0;
  output_frame[35] = 0x0;

  output_frame[36] = 0x0;//crc
  output_frame[37] = 0x0;//crc

  output_frame[38] = 0xfe;
  output_frame[39] = 0x7d;
}





void ARP_REQUEST(void)
{

  memset(output_frame,0xff,0x6);
  memcpy(&output_frame[6],SA_MAC_Address,6);

  output_frame[12] = 0x8;
  output_frame[13] = 0x6;

  output_frame[14] = 0x0;
  output_frame[15] = 0x1;

  output_frame[16] = 0x08;
  output_frame[17] = 0x0;

  output_frame[18] = 0x06;

  output_frame[19] = 0x4;

  output_frame[20] = 0x00;
  output_frame[21] = 0x01;

  memcpy(&output_frame[22],SA_MAC_Address,6);
  memcpy(&output_frame[28],SA_IP_Address,4);
  memset(&output_frame[32],0x0,0x6);
  memcpy(&output_frame[38],DA_IP_Address,4);

  ethernet_WriteRAM(output_frame,42);


}

void TIMER2_IRQHandler(void)
{
  if (TIMER_GetITStatus(MDR_TIMER2, TIMER_STATUS_CNT_ARR))
    {
      TIMER_ClearITPendingBit(MDR_TIMER2, TIMER_STATUS_CNT_ARR);
      RST_CLK_ADCclkSelection(RST_CLK_ADCclkCPU_C1);
      TIMER_Cmd(MDR_TIMER2, DISABLE);
      TIMER_SetCounter(MDR_TIMER2,0x0);
      timer_flag = true;
    }
}
void ADC_IRQHandler (void)
{
  if (ADC1_GetITStatus(ADC1_IT_END_OF_CONVERSION)==SET)

    {
      uint16_t adc_val = ADC1_GetResult();
      float voltage = adc_val;
      voltage = voltage /4096*3.3;
      ADC1_Start();

    }

}

void ETHERNET_IRQHandler(void)
{
  PORT_SetBits(MDR_PORTC,PORT_Pin_9);
  uint16_t Status;
  ETH_StatusPacketReceptionTypeDef packet;

  // Flash LED1
//	PORT_SetBits (MDR_PORTE, MDB_ETH_LED1);

  // Get packet status and clear IT-flag
  Status = ETH_GetMACITStatusRegister(MDR_ETHERNET1);

  // Proccess valid ETH-packet
  if( (MDR_ETHERNET1->ETH_R_Head != MDR_ETHERNET1->ETH_R_Tail) && (Status & ETH_MAC_IT_RF_OK) )
    {
      ETH_ReceivedFrame(MDR_ETHERNET1,input_frame);
      ethernet_header_s* ethernet_header = (ethernet_header_s*)(input_frame);
			if (  ethernet_header->ethernet_type == ETH_TYPE_ARP ){
				ethernet_states = ARP;
			}
    }


  // Copy packet data into buffer
//		packet.Status = ETH_ReceivedFrame(MDR_ETHERNET1, InputFrame);

  // Unicast packet
//		if( packet.Fields.UCA )
//			 ProcessEthIAFrame(InputFrame, packet.Fields.Length);
  // Broadcast packet
//		else if( packet.Fields.BCA )
//			 ProcessEthBroadcastFrame(InputFrame, packet.Fields.Length);

  NVIC_ClearPendingIRQ(ETHERNET_IRQn);
}



unsigned int ethernet_WriteRAM(void* buf, unsigned int size)
{
  unsigned int head, tail;	// ????? ??????, ??????? ?????? ? ?????? ?????? ???????, ? ???
  unsigned short tmp[2];
  unsigned int tmp32;
  unsigned int* src;
  unsigned int* dst;
  unsigned short i;

  head = 	MDR_ETHERNET1->ETH_X_Head;	//
  tail = MDR_ETHERNET1->ETH_X_Tail;	//

  // ?????????? ????????? ???? ? ?????? ???????????
  if(head > tail)
    {
      tmp[0] = head - tail;
      tmp[1] = 0;
    }
  else
    {
      tmp[0] = ETH_RAM_FULL_SIZE - tail;
      tmp[1] = head - ETH_RAM_SIZE_X;
    }

  // ???? ????? ? ?????? ??????, ??? ?? ????? ????????(? ?????? 2-? ??????? ???? ??????????)
  if(size > (tmp[0] + tmp[1] - 2 * sizeof(unsigned int)))
    {
      return 0;
    }

  tmp32 = size;

  src = buf;
  dst = (unsigned int*)(ETH_RAM_BASE_ADDR + tail); //??? ???????????

  *dst++ = tmp32;
  tmp[0] -= sizeof(unsigned int);

  if(dst >= (unsigned int*)(ETH_RAM_BASE_ADDR + ETH_RAM_FULL_SIZE))
    dst = (unsigned int*)ETH_RAM_BASE_X;


  tmp32 = (size + sizeof(unsigned int) - 1)/sizeof(unsigned int);

  if(size <= tmp[0])
    {
      for(i = 0; i < tmp32; i++)
        {
          *dst++ = *src++;
        }
    }
  else
    {
      tmp32 -= tmp[0]/sizeof(unsigned int);

      for(i = 0; i < tmp[0]/sizeof(unsigned int); i++)
        *dst++ = *src++;
      dst = (unsigned int*)ETH_RAM_BASE_X;
      for(i = 0; i < tmp32; i++)
        *dst++ = *src++;
    }

  if(dst >= (unsigned int*)(ETH_RAM_BASE_ADDR + ETH_RAM_FULL_SIZE))
    {
      dst = (unsigned int*)ETH_RAM_BASE_X;
    }

  tmp32 = 0;
  *dst++ = tmp32;

  if(dst >= (unsigned int*)(ETH_RAM_BASE_ADDR + ETH_RAM_FULL_SIZE))
    {
      dst = (unsigned int*)ETH_RAM_BASE_X;
    }

  MDR_ETHERNET1->ETH_X_Tail = (unsigned int)dst;
  MDR_PORTA->RXTX ^= (1 << 13);
  return size;
}